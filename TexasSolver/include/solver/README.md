# Solver ディレクトリ

## 概要

本ディレクトリには、ポーカーゲームの最適戦略を計算するソルバーアルゴリズムの実装が格納されています。CFR（Counterfactual Regret Minimization）を基盤とした各種アルゴリズムが含まれます。

## ファイル

### Solver.h
全てのソルバーの基底クラスです。

**主要機能:**
- ソルバーの共通インターフェース定義
- モンテカルロサンプリングアルゴリズムの列挙型
- 仮想関数による多態性の提供

**定義される列挙型:**
- `MonteCarolAlg`: モンテカルロアルゴリズムの種類
  - `NONE`: サンプリングなし（全探索）
  - `PUBLIC`: Public Chance Sampling
  - `OUTCOME`: Outcome Sampling

### PCfrSolver.h
Public Chance Sampling CFRソルバーの実装です。

**主要機能:**
- Public Chance Samplingを使用したCFRアルゴリズム
- 並列処理対応（マルチスレッド）
- 同型性（Isomorphism）の活用による最適化
- 半精度/単精度浮動小数点による メモリ最適化

**アルゴリズムの特徴:**
- チャンスイベント（カード配布）のみをサンプリング
- プレイヤーアクションは全て探索
- 高速な収束と実用的なメモリ使用量のバランス

**主要メンバ変数:**
- `ranges`: 両プレイヤーのハンドレンジ
- `compairer`: ハンド強度比較オブジェクト
- `iteration_number`: イテレーション回数
- `num_threads`: 使用するスレッド数
- `accuracy`: 目標精度
- `use_isomorphism`: 同型性を使用するかのフラグ
- `use_halffloats`: 半精度浮動小数点の使用フラグ

**主要メソッド:**
- `train()`: CFRアルゴリズムの訓練実行
- `cfr()`: CFRの再帰的計算
- `chanceUtility()`: チャンスノードでの期待値計算
- `actionUtility()`: アクションノードでの期待値計算
- `showdownUtility()`: ショーダウンでの期待値計算
- `dumps()`: 結果のJSON出力
- `get_strategy()`: 計算された戦略の取得
- `get_evs()`: 期待値の取得

### CfrSolver.h
標準CFRソルバーの実装です。

**主要機能:**
- 基本的なCFRアルゴリズム
- サンプリングなしの全探索版

**特徴:**
- 最も正確だが、大きなゲームツリーでは計算コストが高い
- 小規模な問題やベンチマークに適している

### BestResponse.h
ベストレスポンス計算の実装です。

**主要機能:**
- 相手の固定戦略に対する最適反応の計算
- ナッシュ均衡からの搾取可能性（Exploitability）の測定
- ソルバーの精度検証

**主要メソッド:**
- `compute()`: ベストレスポンス戦略の計算
- `get_exploitability()`: 搾取可能性の取得
- `get_ev()`: ベストレスポンスの期待値

## CFRアルゴリズムの概要

### Counterfactual Regret Minimization

CFRは反事実的後悔最小化と呼ばれるアルゴリズムで、以下の原理で動作します:

1. **リグレット計算**: 各アクションを選ばなかったことによる後悔を計算
2. **戦略更新**: リグレットに基づいて戦略を更新（リグレットマッチング）
3. **収束**: イテレーションを重ねることでナッシュ均衡に収束

### Public Chance Sampling

Public Chance Samplingは以下の特徴を持ちます:

- **サンプリング対象**: ボードカード（公開情報）のみ
- **探索対象**: 全てのプレイヤーアクション
- **利点**: 高速で実用的なメモリ使用量
- **欠点**: わずかなバイアスが存在

### 同型性（Isomorphism）の活用

カードのスート同型性を利用して計算量を削減:

```
例: AsKs と AhKh は本質的に同じハンド
→ 重複計算を回避
```

### 精度浮動小数点最適化

- **半精度（FP16）**: メモリ使用量を半分に削減
- **単精度（FP32）**: 標準的な精度
- **倍精度（FP64）**: 最高精度（デバッグ用）

## 使用例

```cpp
auto solver = make_shared<PCfrSolver>(
    tree,           // ゲームツリー
    range1,         // プレイヤー1のレンジ
    range2,         // プレイヤー2のレンジ
    board,          // 初期ボード
    compairer,      // ハンド比較器
    deck,           // デッキ
    1000,           // イテレーション回数
    false,          // デバッグモード
    10,             // 進捗表示間隔
    "log.txt",      // ログファイル
    "discounted",   // トレーナータイプ
    Solver::MonteCarolAlg::PUBLIC,  // サンプリングアルゴリズム
    100,            // ウォームアップイテレーション
    0.5,            // 目標精度
    true,           // 同型性使用
    1,              // 半精度使用
    8               // スレッド数
);

solver->train();
auto strategy = solver->dumps(true, 2);
```

## 性能最適化

### 並列処理
- OpenMPを使用したマルチスレッド処理
- リバーラウンドでの並列化が特に効果的

### メモリ最適化
- 半精度浮動小数点によるメモリ削減
- 同型性の活用による重複排除

### 計算最適化
- Public Chance Samplingによる探索空間削減
- ウォームアップイテレーションによる初期収束の加速
